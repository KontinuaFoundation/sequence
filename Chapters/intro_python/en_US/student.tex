\chapter{Introduction to Python}
In this chapter we will discuss the very basics of Python. No we are not talking about snake anatomy, but the programming language Python. Python is a high-level, interpreted programming language known for its readability and versatility. It is widely used in various fields such as web development, data analysis, artificial intelligence, scientific computing, and more. It can be used for data parsing, visualization, and even machine learning. Python's syntax is designed to be easy to read and write, making it an excellent choice for beginners and experienced programmers alike. Throughout this chapter, we encourage you to write out the provided lines of code yourself! This will reinforce skills like computer literacy, Python syntax and troubleshooting, and of course, typing speed.

\section{Getting Started with Python}
To get started with Python, you need to have it installed on your computer. You can download the latest version of Python from the official website: \url{https://www.python.org/downloads/}. Follow the installation instructions for your operating system. \index{installing python}%FIXME what else needs to be included here.

Once you have python installed, you can write and run Python code using various methods:
\begin{itemize}
    \item \textbf{Interactive Shell:} You can open a terminal or command prompt and type \mintinline{python}{python} or \mintinline{python}{python3} to start an interactive Python shell where you can type and execute Python commands line by line.
    \item \textbf{Script Files:} You can write your Python code in a text file with a \mintinline{python}{.py} extension and run it using the command \mintinline{python}{python filename.py} or \mintinline{python}{python3 filename.py} in the terminal.
    \item \textbf{Integrated Development Environments (IDEs):} There are several IDEs available for Python, such as PyCharm, VSCode, and Jupyter Notebooks, which provide a more user-friendly environment for writing and running Python code. We will assume you will use VSCode, as it is widely used among computer scientists and devlopers around the world, and has direct integration to GitHub. 
\end{itemize}

We are going to install VSCode as our IDE for this course. You can download it from \url{https://code.visualstudio.com/}. After installing VSCode, you will also need to install the Python extension for VSCode, which can be found in the Extensions Marketplace within VSCode.
\subsection{The Console and Running Python Programs}

When working with Python, it is important to understand the difference between
\emph{writing code} and \emph{executing code}. Writing code simply means typing
instructions into a file using a text editor or IDE. Executing code means telling
Python to read those instructions and perform them.

The \emph{console}, also called the \emph{terminal} or \emph{command prompt}, is a
text-based interface where you can run programs and view their output. Any text
printed using the \mintinline{python}{print()} function will appear in the console.

When you run a Python program, Python reads your file from top to bottom and
executes each line in order. This is an important idea that will come up often:
\textbf{Python code is executed sequentially, one line at a time}.

\subsection{Running a Python File}

To run a Python file, you must use the console. In VSCode, you can open the
integrated terminal by selecting \mintinline{python}{Terminal → New Terminal} from the menu.
Make sure your terminal is open in the same folder as your Python file.

If your file is named \mintinline{python}{hello.py}, you can run it by typing:

\begin{minted}{python}
python hello.py
\end{minted}

or, on some systems:

\begin{minted}{python}
python3 hello.py
\end{minted}

After pressing Enter, Python will execute the file and display any output in the
console. If there are errors in your code, Python will stop execution and display
an error message instead. You may also see a green play button at the top of your window, you could also run your program with that!

At this point, it is helpful to remember:
\begin{itemize}
    \item Writing code does nothing by itself
    \item Code only runs when you explicitly execute the file
    \item Output from \mintinline{python}{print()} appears in the console
\end{itemize}



\section{Output \mintinline{python}{print}}
Let's talk more about the \mintinline{python}{print()} statement. It can take a string, multiple variables, or a combination of strings and variables. We are going to introduce the syntax first, and then expand on the definitions later.\index{print}

\begin{minted}{python}
x = "This is a variable."
print("This is a string.", x)
\end{minted}
This should output \mintinline{text}{This is a string. This is a variable}. You can also do multiple variables:
\begin{minted}{python}
x = "Good"
y = "Morning,"
z = "Chicago"
print(x, y, z)
\end{minted}
This will output \mintinline{text}{Good Morning, Chicago}. Alternatively, printing can have addition within it:
\begin{minted}{python}
x = "Good"
y = "Morning,"
z = "Chicago"
print(x+y+z)
\end{minted}
This will output \mintinline{text}{GoodMorning,Chicago}. Notice the difference!

If you want to combine numbers and strings,
\begin{minted}{python}
x = "it is"
y=78
z="degrees outside"
print(x+y+z)
\end{minted}
\textbf{\emph{This will not work!}} Instead, we should use commas:
\begin{minted}{python}
x = "it is"
y=78
z="degrees outside"
print(x, y, z)
\end{minted}
This will correctly output ``it is 78 degrees outside''

By default, a space is added in between each argument (where the commas would be).

We can change what seperates each variable by the \mintinline{python}{sep=} argument. 
\begin{minted}{python}
x = "it is"
y=78
z="degrees outside"
print(x, y, z, sep="..!..")
\end{minted}
This will output \mintinline{text}{it is..!..78..!..degrees outside}

By default, Python includes a new line at the end of each print statement. We can alter this to anything else by using the \mintinline{python}{end=} argument:
\begin{minted}{python}
print("Good Morning, Chicago.", end="!!")
\end{minted}
Outputting \mintinline{text}{Good Morning, Chicago.!!} to the console, with no new line character inserted. Note that the next print statement will continue on the same line unless it contains a new line character.
\begin{minted}{python}
print("Hello World!", end=" ")
print("I will print on the same line.")
\end{minted}
We have used all this terminology like strings and variables a lot, let's dive a bit deeper into it!
\section{Datatypes and Variables}

There are many different datatypes in Python, and all of them can be passed to \mintinline{python}{print} function. Here's the main few: 
\begin{description}
    \item[Strings] Strings are just a sequence of characters. Anything closed between quotes gets included in the string, such as "This is the Python Chapter for the Kontinua Sequence!!\%\^\&\*()-+=1234567890~\&"\index{strings}
    \item[Integers] Integers are any whole number, positive negative or 0. Theoretically, integer values can go on for infinity, but it is important to understand they take up space in computer memory.\index{integers}
    \item[Floats]  Floats, or floating point values, are numbers that include decimal places. Division can be done between integers and floats but may result in a different value.\index{floats}
    \item[Booleans] Booleans only two values: \mintinline{python}{True} or \mintinline{python}{False}. The output of conditional statements (such as if's or while's) are booleans. They only answer Yes and No questions, and are important on deciding between two possible paths in code.\index{booleans}
    \item[Sequence Types] Sequences are consecutive lists or pairs of other data types can be represented in various froms: \mintinline{python}{list}, \mintinline{python}{set}, and \mintinline{python}{tuple}. Values are accessed by positions. \index{sequnce types}
    \item[Mapping Types] The main mapping type is a \mintinline{python}{dict}, short for dictionary. Mapping types store values as key–value pairs instead of positions. You access items using a key, not an index.\index{dictionary}
\end{description}

Let's create some of these in our code:
\begin{minted}{python}
x = 5
y = 5.6
z = True
a = [x, y, z]
\end{minted}

A \emph{variable} is a container for information, usually containing one of the datatypes established above. In Python, variables are assigned using the assignment operator $=$, with the name of the variable on the left side of the operator and the value it is assigned to on the right side. 

Python has specific naming rules for variables. The name
\begin{itemize}
    \item Must start with a letter or underscore
    \item Cannot contain spaces
    \item Are case-sensitive
\end{itemize}

In our code above, \mintinline{python}{x} is a \emph{variable} containing the number $5$, an Integer. \mintinline{python}{y} contains the float $5.6$, while \mintinline{python}{z} is a boolean with the value \mintinline{python}{True}. We then created a list containing the variables \mintinline{python}{x}, \mintinline{python}{y}, and \mintinline{python}{z}.

A unique feature of Python is that variables can change their datatypes even after assignment. We can see the datatype of an object using the \mintinline{python}{type()}
\begin{minted}{python}
x = 10
print(x)
print(type(x))

x = "Hello!"
print(x)
print(type(x))
\end{minted}

Output:
% changed to text bc of the output formatting
\begin{minted}{text}
10
<class 'int'>
Hello!
<class 'str'>
\end{minted}

Notice that, because of that feature, the datatype of a variable is not defined beforehand. This is a core difference between Python and other programming languages like Java or C++, which we will explore in the future. 

We can also define our floats using scientific notation.
\begin{minted}{python}
x = 1e3     # 1000.0
y = 2.5e-4  # 0.00025
\end{minted}

\begin{Exercise}[label=datatypes1, title=Identify the variable type]
Below are 5 variables defined in Python. Identify their type as \mintinline{python}|str|, \mintinline{python}|float|, \mintinline{python}|bool|, \mintinline{python}|list|, or \mintinline{python}|int| by filling in the table below. 
\begin{minted}{python}
a = 10
b = 3.5
c = "10"
d = True
e = [1, 2, 3]
\end{minted}

\begin{tabular}{|c|c|p{4cm}|}
\hline
Variable & Value & Data Type \\
\hline
a & 10 & \\
\hline
b & 3.5 & \\
\hline
c & "10" & \\
\hline
d & True & \\
\hline
e & [1, 2, 3] & \\
\hline
\end{tabular}

\end{Exercise}
\begin{Answer}[ref=datatypes1]
\begin{tabular}{|c|c|p{4cm}|}
\hline
Variable & Value & Data Type \\
\hline
a & 10 & \mintinline{python}|int|\\
\hline
b & 3.5 & \mintinline{python}|float|\\
\hline
c & "10" & \mintinline{python}|str|\\
\hline
d & True & \mintinline{python}|bool|\\
\hline
e & [1, 2, 3] & \mintinline{python}|list|\\
\hline
\end{tabular}
\end{Answer}

\begin{Exercise}[label=datatypes2, title=What does this do?]
What is the output of the following code?
\begin{minted}{python}
print(type(3.0) == type(3))
\end{minted}
\end{Exercise}
\begin{Answer}[ref=datatypes2]
\begin{minted}{text}
False
\end{minted}
\end{Answer}

\section{Operations}
Operations can be done on both variables and numbers alike. Most commonly they will be used for mathematical operations or simplifying operations of equivalence. 
\subsection{Arithmetic Operations}
Math operations in Python are very similar to standard math operations. We need them for any type of data operation or math parsing.

\index{operations}\index{addition}\index{subtraction}\index{multiplication}\index{division}\index{modulus}\index{floor division}

\begin{minted}{python}
    a = 100
    b = 3
    c = 100.0
    d = -100
    print(a + b) # addition
    print(a - b) # subtraction
    print(a * b) # multiplication
    print(a / b) # division (results in a float)
    print(a % b) # modulus (remainder) operator - useful for division checks
    print(a ** b) # exponentiation
    print(a // b) # floor division
    print(c // b) # floor division as a float
    print(d // b) # negative flooring goes further DOWN
\end{minted}

Output:
\begin{minted}{python}
    103
    97
    300
    33.333333333333336
    1
    1000000
    33
    33.0
    34
\end{minted}

Note that division by $0$ is not a valid operation, just as in algebra. This will cause an \mintinline{python}{ZeroDivisionError}.
\subsection{Augmented Assignment Operators}
You may want to do the following operation
\begin{minted}{python}
x = 0
while True:
    print(x)
    x = x + 1
\end{minted}
This would print the counting numbers, increasing by 1, forever. The \mintinline{python}{x = x + 1} rewrites the value of \mintinline{python}{x} equal to the current value of \mintinline{python}{x}, and adds one to it. There is a short hand for this kind of operation, called an \newterm{augmented assignment operator}\index{augmented assignment operator}, which combines assignment operators and operations. These are commonly used in loops and accumulation counters:
\begin{minted}{python}
x = 10
x += 5   # same as x = x + 5
x -= 3   # same as x = x - 3
x *= 2   # same as x = 2 * x
x /= 4   # same as x = x / 4
\end{minted}
Following order of operations, \mintinline{python}{x = 6} after all lines are executed. 

\subsection{Summary}
\begin{itemize}
    \item Math operations are done with \mintinline{python}{+}, \mintinline{python}{-}, \mintinline{python}{*}, and \mintinline{python}{/}
    \item Augmented Operations \mintinline{python}{+=, -=, *=, /=} are common for loops and counting operations. 
\end{itemize}

\begin{Exercise}[label=operations1,title=Tracing Chart]
Let's create a tracing chart. What happens after each line of code is run?
\begin{minted}{python}
n = 5
m = "3"
n = n + 1
m = m + "1"
\end{minted}

\begin{tabular}{|c|p{4cm}|p{4cm}|}
\hline
Line Executed & n (value, type) & m (value, type) \\
\hline
After line 2 &  & \\
\hline
After line 3 &  & \\
\hline
After line 4 &  & \\
\hline
\end{tabular}
\end{Exercise}
\begin{Answer}[ref=operations1]
\begin{tabular}{|c|p{4cm}|p{4cm}|}
\hline
Line Executed & n (value, type) & m (value, type) \\
\hline
After line 2 & (5, int) & ("3", str)\\
\hline
After line 3 & (6, int) & ("3", str)\\
\hline
After line 4 & (6, int) & ("31", str)\\
\hline
\end{tabular}
\end{Answer}
\section{Input and Output}
So far, we have only displayed information using the \mintinline{python}{print()} function.
While output is useful, most programs also need a way to receive information
from the user. In Python, this is done using the built-in \mintinline{python}{input()} function.\index{input}

\subsection{Getting User Input}

The \mintinline{python}{input()} function pauses the program and waits for the user to type
something into the console. Whatever the user types is then returned and can be
stored in a variable.

\begin{minted}{python}
name = input("Enter your name: ")
print("Hello,", name)
\end{minted}

In this example:
\begin{itemize}
    \item The text inside \mintinline{python}{input()} is displayed as a prompt in the console
    \item The program waits for the user to type a response and press Enter
    \item The entered text is stored in the variable \mintinline{python}{name}
    \item The \mintinline{python}{print()} function then outputs a greeting using that value
\end{itemize}

\subsection{Input Always Returns a String}

A very important rule in Python is that \mintinline{python}{input()} \textbf{always returns a
string}, even if the user types a number. This means that mathematical operations
cannot be performed on input values unless they are converted to a numeric type.

Consider the following incorrect example:

\begin{minted}{python}
age = input("Enter your age: ")
print(age + 1)
\end{minted}

This code will result in an error, because Python cannot add a number to a string.

To perform calculations, the input must be \emph{cast} to a different datatype.

\subsection{Casting Input Values}
\index{casting}
Casting is the process of converting one datatype into another. Python provides
built-in functions such as \mintinline{python}{int()}, \mintinline{python}{float()}, and \mintinline{python}{str()} for
this purpose.

\begin{minted}{python}
age = int(input("Enter your age: "))
print(age + 1)
\end{minted}

Here:
\begin{itemize}
    \item \mintinline{python}{input()} returns a string
    \item \mintinline{python}{int()} converts that string into an integer
    \item The program can now perform arithmetic operations
\end{itemize}

\subsection{Common Input Errors}

If the user enters something that cannot be converted to the requested datatype,
Python raises a runtime error called a \mintinline{python}{ValueError}. For example:

\begin{minted}{python}
age = int(input("Enter your age: "))
\end{minted}

If the user types \mintinline{python}{hello} instead of a number, Python will produce an error
similar to the following:

\begin{minted}{python}
ValueError: invalid literal for int() with base 10
\end{minted}

This error occurs because the string \mintinline{python}{"hello"} cannot be converted into an integer. Handling these types of errors will be discussed later when we introduce \mintinline{python}{try-except} statements.

\subsection{Summary}

\begin{itemize}
    \item \mintinline{python}{print()} is used to display output to the console
    \item \mintinline{python}{input()} is used to receive text input from the user
    \item \mintinline{python}{input()} always returns a string
    \item Casting is required to convert input into numeric types
\end{itemize}

\begin{Exercise}[label=input1, title=User Input Types]
\begin{minted}{python}
x = input("Enter a number: ")
print(x + 5)
\end{minted}
What will happen when this code is run and the user enters \mintinline{python}{10}? If there is an issue, explain what it is, why it occurs, and how to fix it.
\end{Exercise}
\begin{Answer}[ref=input1]
The code will raise a \mintinline{python}{TypeError} because \mintinline{python}{x} is a string and cannot be added to the integer \mintinline{python}{5}. The error message will be similar to:
\begin{minted}{python}
TypeError: can only concatenate str (not "int") to str
\end{minted}
To fix this, we need to cast \mintinline{python}{x} to an integer using \mintinline{python}{int()}:
\begin{minted}{python}
x = int(input("Enter a number: "))
print(x + 5)
\end{minted}
\end{Answer}
\section{Conditionals, Loops, and Match-Case}
\index{conditionals}
\index{loops}
\index{match-case}
Most programs need to make decisions and repeat actions. Programmers do not want to write the same code multiple times, as this introduces \textit{redundancy}. In Python, this is done using \emph{conditionals} and \emph{loops}. Conditionals allow the program to
choose between different paths of execution, while loops allow code to be run
multiple times.

\subsection{Conditional Statements}

Conditional statements execute code only if a given condition is true. Python
uses the keywords \mintinline{python}{if}, \mintinline{python}{elif}, and \mintinline{python}{else} to define these
conditions.

\begin{minted}{python}
x = 10

if x > 0:
    print("x is positive")
elif x == 0:
    print("x is zero")
else:
    print("x is negative")
\end{minted}

In this example:
\begin{itemize}
    \item The expression after \mintinline{python}{if} is evaluated as a boolean
    \item If the condition is \mintinline{python}{True}, the indented block runs
    \item If it is \mintinline{python}{False}, Python checks the next condition. The \mintinline{python}{elif} block is the only way to check another branch after one is returned \mintinline{python}{False}. The \mintinline{python}{else} branch is a last resort, and only runs if all previous statements are false
    \item Only one branch of the conditional will execute
\end{itemize}

It is important to note that \textbf{indentation is required} in Python. All
statements belonging to a conditional block must be indented at the same level.

\subsection{Boolean Expressions}

Conditions are built using comparison and logical operators. These expressions
always evaluate to either \mintinline{python}{True} or \mintinline{python}{False}.

\begin{minted}{python}
a = 5
b = 10

print(a < b)   # less than
print(a == b)  # equal to
print(a != b)  # not equal to
\end{minted}

Logical operators can be used to combine conditions. Condtions can be \emph{strung together} using \mintinline{python}{and}, \mintinline{python}{or}, and \mintinline{python}{not}

\begin{minted}{python}
x = 7

if x > 0 and x < 10:
    print("x is between 1 and 9")
if x > 0 or x < -3:
    print("x is greater than 0 or less than -3")

y = False
print(not y)

\end{minted}

\subsection{Loops}

Loops allow code to be repeated multiple times. Python provides two main types of
loops: \mintinline{python}{for} loops and \mintinline{python}{while} loops.

To define a loop, Python uses the keywords \mintinline{python}{for} and \mintinline{python}{while}, followed by a condition or sequence to iterate over.
\begin{itemize}
    \item the loop header, with correctly defined endpoints
    \item a colon \mintinline{python}{:}
    \item an indented block of code to iterate over
\end{itemize}
\subsection{For Loops}
\index{for loops}
A \mintinline{python}{for} loop is used to iterate over a sequence, such as a list or a range
of numbers.

\begin{minted}{python}
for i in range(5):
    print(i)
\end{minted}

This code will print the numbers 0 through 4. The \mintinline{python}{range()} function
generates a sequence of integers starting at 0 and stopping before the given
value.

\begin{minted}{python}
numbers = [10, 20, 30]

for n in numbers:
    print(n)
\end{minted}

\subsection{While Loops}
\index{while loops}
A \mintinline{python}{while} loop repeats as long as a condition remains true.

\begin{minted}{python}
x = 5

while x > 0:
    print(x)
    x -= 1
\end{minted}

In this example:
\begin{itemize}
    \item The condition is checked before each iteration
    \item The loop stops once the condition becomes \mintinline{python}{False}
\end{itemize}

Care must be taken to ensure that the condition eventually becomes false.
Otherwise, the program will enter an infinite loop, one which never stops and the computer will run forever, risking hardware component issues. 

\subsection{Breaking and Continuing Loops}
\index{break}
Python provides keywords to control loop execution.

\begin{minted}{python}
for i in range(10):
    if i == 5:
        break
    print(i)
\end{minted}

The \mintinline{python}{break} statement immediately exits the loop.

\begin{minted}{python}
for i in range(5):
    if i == 2:
        continue
    print(i)
\end{minted}

The \mintinline{python}{continue} statement skips the current iteration and moves to the next
one.

\subsection{Match-Case Statements}
\index{match-case}
Python also provides the \mintinline{python}{match-case} statement, which allows a value to be
compared against several possible patterns. This is similar to a switch
statement in other programming languages.

\begin{minted}{python}
command = input("Enter a command: ")

match command:
    case "start":
        print("Starting program")
    case "stop":
        print("Stopping program")
    case "pause":
        print("Pausing program")
    case _:
        print("Unknown command")
\end{minted}

The underscore (\mintinline{python}{\_}) acts as a default case if no other patterns match.

\subsection{Summary}

\begin{itemize}
    \item Conditionals allow programs to make decisions
    \item Boolean expressions evaluate to \mintinline{python}{True} or \mintinline{python}{False}
    \item Loops allow code to be repeated efficiently
    \item \mintinline{python}{for} loops iterate over sequences
    \item \mintinline{python}{while} loops repeat based on a condition
    \item \mintinline{python}{match-case} provides a structured way to handle multiple cases
\end{itemize}
\begin{Exercise}[label=conditionals1, title=Predict the Output]
Fill in the table with the outputs for the given inputs.
\begin{minted}{python}
x = int(input("Enter a number: "))

if x > 10:
    print("Large")
elif x == 10:
    print("Ten")
else:
    print("Small")
\end{minted}
\begin{tabular}{|c|c|}
\hline
Input & Output \\
\hline
5 & \\
\hline
10 & \\
\hline
15 & \\
\hline
\end{tabular}
\end{Exercise}
\begin{Answer}[ref=conditionals1]
\begin{tabular}{|c|c|}
\hline
Input & Output \\
\hline
5 & Small \\
\hline
10 & Ten \\
\hline
15 & Large \\
\hline
\end{tabular}
\end{Answer}

\begin{Exercise}[label=loops1, title=Fill in the Blanks: Loop Edition]
Fill in the following code to print all even numbers from 0 to 20 (inclusive).
\begin{minted}{python}
for i in __________:
    print(__________)
\end{minted}
\end{Exercise}
\begin{Answer}[ref=loops1]
\begin{minted}{python}
for i in range(0, 21, 2):
    print(i)
\end{minted}
\end{Answer}

\section{Lists and Strings}
We talked about creating strings, any set of characters between quotes. These can either be single quotes \mintinline{python}{' '} or double quotes \mintinline{python}{"   "}. \index{strings}

Multiline strings must be surrounded by three quotations on each side of the text sequence. 
\begin{minted}{python}
a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
\end{minted}

Strings are an example of a \emph{sequence type}, meaning they store values in a
specific order and allow individual elements to be accessed using an index.

\subsection{Indexing Strings}
\index{strings!indexing}
Each character in a string has a position, called an \emph{index}. Indexing in\index{index}
Python begins at 0, so the first character is at index 0. Think of it like asking the question for each letter: ``How far from the start is this element?'' The first element is zero positions away from the start, so its index is 0. The last element is always at index $n-1$, where $n$ is the length of string. In memory, all of these characters are stored consecutively. 

\begin{minted}{python}
word = "Python"

print(word[0])
print(word[1])
print(word[5])
\end{minted}
Output:
\begin{minted}{python}
P
y
n
\end{minted}
Attempting to access an index that does not exist will result in a runtime error.

\subsection{Length of a String}
\index{strings!length}
The number of characters in a string can be found using the built-in
\mintinline{python}{len()} function.

\begin{minted}{python}
word = "Python"
print(len(word))
\end{minted}

Output:
\begin{minted}{python}
6
\end{minted}

\subsection{Iterating Over Strings}
\index{strings!iterating}
Strings can be iterated over one character at a time using a \mintinline{python}{for} loop.

\begin{minted}{python}
for char in "Hello":
    print(char)
\end{minted}

This loop runs once for each character in the string.

\subsection{String Methods}
\index{string methods}
Strings come with built-in functions, called \emph{methods}, that perform common
operations. These methods are called using dot notation.

\begin{minted}{python}
text = "  Python Programming  "

print(text.upper())
print(text.lower())
print(text.strip())
\end{minted}

Common string methods include:
\begin{itemize}
    \item \mintinline{python}{upper()} converts all characters to uppercase
    \item \mintinline{python}{lower()} converts all characters to lowercase
    \item \mintinline{python}{strip()} removes leading and trailing whitespace
\end{itemize}

\subsection{Lists}

A list is another sequence type used to store multiple values in a single
variable. Lists are created using square brackets, with elements separated by
commas.

\begin{minted}{python}
numbers = [1, 2, 3, 4]
\end{minted}

Lists can store values of different datatypes, including strings, numbers, booleans, and even other lists.

\begin{minted}{python}
data = [10, 3.14, True, "Python"]
\end{minted}

\subsection{Indexing Lists}

Like strings, lists are indexed starting at 0.

\begin{minted}{python}
numbers = [10, 20, 30]

print(numbers[0])
print(numbers[2])
\end{minted}

Output:
\begin{minted}{python}
10
30
\end{minted}

For nested lists, you search an indexe using a bracket for every nested list until you reach the element you are aiming to reach. Later, we will talk about \mintinline{python}{.json} files, which are files essentially comprised of strung-nested lists. 
\begin{minted}{python}
nested_numbers = [0, [1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(numbers[0])
print(numbers[1][2])
print(numbers[2][1])
\end{minted}

Output:
\begin{minted}{python}
0
3
5
\end{minted}
\subsubsection{Slicing Strings}
You can also use \emph{slicing} in Python to get all elements between two indices. 
This syntax is Python-specific, although there are equivalences in other programming languages. 
This syntax works for \emph{both} lists and strings.

For any sequence, we can slice it or operate on it with the following index notation:
\begin{minted}{python}
sequence[start : stop : step]
\end{minted}
where \mintinline{text}|start| is the index to begin at (inclusive), \mintinline{text}|end| is the index to end at (exclusive), and \mintinline{text}|step|, an optional argument for how many items to skip.

\begin{minted}{python}
text = "abcdef"

text[1:4]    # 'bcd'
text[:3]     # 'abc'
text[3:]     # 'def'
text[::2]    # 'ace'
text[::-1]   # 'fedcba'  (reverse string)
\end{minted}
The above example slices a string in a few different ways. Let's look at list slicing:


\begin{minted}{python}
nums = [0, 1, 2, 3, 4, 5]

nums[2:5]    # [2, 3, 4]
nums[:4]     # [0, 1, 2, 3]
nums[4:]     # [4, 5]
nums[::2]    # [0, 2, 4]
nums[::-1]   # [5, 4, 3, 2, 1, 0]
\end{minted}

Negative indices start from the end, and work the way up the sequence:
\begin{minted}{python}
text = "python"

text[-3:]    # 'hon'
text[:-2]    # 'pyth'
\end{minted}

Note that setting a variable to a sliced string creates a new string object, while leaving the original unchanged.
\begin{Exercise}[label=slicing1,title=Mystery Sequence]
    What will the code \mintinline{python}|seq[:]| output, assuming \mintinline{python}|seq = [a, f, j, k]| is a valid list?
\end{Exercise}
\begin{Answer}[ref=slicing1]
    The start index is omitted and the end index is omitted, which means they are 0 and \mintinline{python}|len(seq)|$=4$ respectively. Since the bounds are $0$ and $4-1=3$, every index is included, in the given order. Therefore, \mintinline{python}|seq[:]| returns a copy of the given string, \mintinline{python}|[a, f, j, k]|
\end{Answer}

\begin{Exercise}[label=indexing1, title=Computer... Indexing!]
You are given the following code:
\begin{minted}{python}
word = "computer"
\end{minted}
What is the output of each of the following expressions?
\begin{minted}{python}
print(word[0])
print(word[2])    
print(word[-1])   
print(word[-3])
print(word[3:6])  
\end{minted}
\end{Exercise}
\begin{Answer}[ref=indexing1]
\begin{minted}{text}
c
m
r
t
put
\end{minted}
\end{Answer}
\subsection{Modifying Lists}

Unlike strings, lists are \emph{mutable}, meaning their contents can be changed
after creation.

\begin{minted}{python}
numbers = [1, 2, 3]
numbers[1] = 10
print(numbers)
\end{minted}

Output:
\begin{minted}{python}
[1, 10, 3]
\end{minted}

\subsection{List Length and Iteration}

The number of elements in a list can be found using the \mintinline{python}{len()} function.

\begin{minted}{python}
numbers = [1, 2, 3]
print(len(numbers))
\end{minted}

Lists can be iterated over using a \mintinline{python}{for} loop.

\begin{minted}{python}
numbers = [1, 2, 3]

for n in numbers:
    print(n)
\end{minted}

\subsection{Common List Methods}

Lists include built-in methods that allow elements to be added or removed.

\begin{minted}{python}
numbers = [1, 2, 3]
numbers.append(4)
numbers.remove(2)
print(numbers)
\end{minted}

Common list methods include:
\begin{itemize}
    \item \mintinline{python}{append()} - adds an element to the end of the list
    \item \mintinline{python}{remove()} - removes the first occurrence of a value
    \item \mintinline{python}{pop()} – removes and returns an element by index
\end{itemize}

\subsection{Strings vs Lists}

Although strings and lists are both sequence types, there is an important
difference between them.

\begin{itemize}
    \item Strings are immutable and cannot be modified after creation
    \item Lists are mutable and can be changed
\end{itemize}

\subsection{Summary}

\begin{itemize}
    \item Strings and lists are sequence types
    \item Indexing starts at 0
    \item The \mintinline{python}{len()} function returns the size of a sequence
    \item Strings are immutable
    \item Lists are mutable and support modification
\end{itemize}

\begin{Exercise}[label=lists1, title=What's in your backpack?]
Let's say the following code is run.
\begin{minted}{python}
items = ["pen", "book", "eraser"]

items.append("ruler")
items.pop()
items.remove("book")
items.append("marker")
\end{minted}
Fill in the following chart with the contents of the \mintinline{python}|items| list after each operation.
\begin{tabular}{|c|p{0.5\textwidth}}
\hline
Line Execution & \mintinline{python}|items| content \\
\hline
After Line 1 & \mintinline{python}|items = ["pen", "book", "eraser"]| \\
\hline
After Line 3 & \\
\hline
After Line 4 & \\
\hline
After Line 5 & \\
\hline
After Line 6 & \\
\hline
\end{tabular}
\end{Exercise}

\begin{Answer}[ref=lists1]
\begin{tabular}{|c|p{0.5\textwidth}|}
\hline
Line Execution & \mintinline{python}|items| content \\
\hline
After Line 1 & \mintinline{python}|items = ["pen", "book", "eraser"]| \\
\hline
After Line 3 & \mintinline{python}|items = ["pen", "book", "eraser", "ruler"]| \\
\hline
After Line 4 & \mintinline{python}|items = ["pen", "book", "eraser"]| \\
\hline
After Line 5 & \mintinline{python}|items = ["pen", "eraser"]| \\
\hline
After Line 6 & \mintinline{python}|items = ["pen", "eraser", "marker"]| \\
\hline
\end{tabular}
\end{Answer}

\section{Functions}
\index{functions}
As our programs get larger, we begin to repeat the same sets of steps again and again.
Rather than copying and pasting code (which is hard to maintain and easy to break),
we can group instructions into \emph{functions}. A \newterm{function}\index{functions!definition}
is a named block of code that performs a task. Once a function is defined, it can be
\emph{called} (used) as many times as needed.

You have already used functions before, even if you did not know it! For example,
\mintinline{python}{print()}, \mintinline{python}{input()}, \mintinline{python}{len()}, and \mintinline{python}{type()}
are built-in Python functions.

\subsection{Defining and Calling a Function}
\index{functions!def}
To define a function in Python, we use the \mintinline{python}{def} keyword, followed by:
\begin{itemize}
    \item a function name
    \item parentheses \mintinline{python}{()}
    \item a colon \mintinline{python}{:}
    \item an indented block of code
\end{itemize}

\begin{minted}{python}
def say_hello():
    print("Hello!")
    print("Welcome to Python.")
\end{minted}

This code \emph{defines} the function, but it does not run the code inside it yet.
To execute the function, we must \emph{call} it by using its name followed by parentheses:

\begin{minted}{python}
say_hello()
\end{minted}

When Python reaches a function call, it temporarily jumps into the function, runs the
indented code, and then returns to the line after the call. Just like conditionals and loops,
\textbf{indentation matters}.

\subsection{Parameters and Arguments}
\index{functions!parameters}
Most functions are more useful when they can work with different values.
A \newterm{parameter}\index{functions!parameter} is a variable name listed inside the parentheses of a function definition.
An \newterm{argument}\index{functions!argument} is the actual value you pass into the function when you call it.

\begin{minted}{python}
def greet(name):
    print("Hello", name)
\end{minted}

Here, \mintinline{python}{name} is a parameter. We can call the function with different arguments:

\begin{minted}{python}
greet("Alex")
greet("Chicago")
\end{minted}

\subsection{Return Values}
\index{functions!return}
Some functions \emph{return} a value. Returning a value allows the function to produce a result
that can be stored in a variable or used in an expression.

\begin{minted}{python}
def add(a, b):
    return a + b
\end{minted}

Now we can use the returned value:

\begin{minted}{python}
x = add(3, 4)
print(x)
\end{minted}

Output:
\begin{minted}{text}
7
\end{minted}


We can alter the function to expect a certain parameter type, such as integers, and return a specific type as well:
\begin{minted}{python}
def add(a: int, b: int) -> int:
    return a + b
\end{minted}

It is important to note that Python won't raise a TypeError if you pass in the wrong type, but this is a helpful way to document your code for other programmers, which you may often work with, and yourself.

We can force the parameters to be a certain type, and raise an error if the wrong type is passed in:
\begin{minted}{python}
def add(a: int, b: int) -> int:
    if not isinstance(a, int) or not isinstance(b, int):
        raise TypeError("Both arguments must be integers")
    return a + b
\end{minted}


\textbf{Important:} \mintinline{python}{print()} displays information to the console, but it does not return a useful value.
\mintinline{python}{return} sends a value back to where the function was called. Functions that do not have a \mintinline{python}{return} statement return \mintinline{python}{None} by default, and are often called \emph{void} functions.

\subsection{Scope}
\index{scope}
A variable created inside a function only exists inside that function. This idea is called \newterm{scope}.
If you define a variable inside a function, you cannot use it outside of the function unless you return it.

\begin{minted}{python}
def make_number():
    x = 10
    return x

y = make_number()
print(y)
\end{minted}

The variable \mintinline{python}{x} exists only inside \mintinline{python}{make_number()}, but the value it returns
is stored in \mintinline{python}{y} outside the function.

\subsection{Summary}
\begin{itemize}
    \item Functions group code into reusable blocks
    \item Functions are defined with \mintinline{python}{def} and called using parentheses
    \item Parameters receive input values (arguments) when a function is called
    \item \mintinline{python}{return} sends a value back to the caller
    \item Variables inside a function have local scope
\end{itemize}

\begin{Exercise}[label=functions1, title=Tracing a Function Call]
Consider the following code:
\begin{minted}{python}
def double(x):
    return x * 2

a = 3
b = double(a)
print(b)
\end{minted}
What is printed? What is the value of \mintinline{python}{a} after the program runs?
\end{Exercise}

\begin{Answer}[ref=functions1]
The function returns \mintinline{python}{3 * 2}, which is \mintinline{python}{6}, so the program prints:
\begin{minted}{text}
6
\end{minted}
The value of \mintinline{python}{a} is still \mintinline{python}{3} because the function does not change \mintinline{python}{a}; it only uses its value to compute a result.
\end{Answer}

\begin{Exercise}[label=functions2, title=Write a Function]
Write a function called \mintinline{python}{is_even(n)} that returns \mintinline{python}{True} if \mintinline{python}{n} is even and \mintinline{python}{False} otherwise.
Then show an example call to your function using \mintinline{python}{n = 7}.
\end{Exercise}

\begin{Answer}[ref=functions2]
\begin{minted}{python}
def is_even(n):
    return n % 2 == 0

print(is_even(7))
\end{minted}
This prints \mintinline{python}{False} because 7 is not divisible by 2.
\end{Answer}

\section{Classes and More Basic Object-Oriented Programming}
\index{classes}
\index{object-oriented programming}

So far, we have worked mostly with individual variables, lists, and functions.
As programs grow larger, it becomes useful to group related data and behavior
together. \newterm{Object-Oriented Programming}\index{object-oriented programming}
(OOP) is a programming style that organizes code around \emph{objects} rather than
individual functions.

In Python, objects are created from \emph{classes}. A \newterm{class}\index{classes!definition}
is a blueprint for creating objects that contain both data (variables) and
behavior (functions).

\subsection{Defining a Class}
\index{classes!defining}
A class is defined using the \mintinline{python}{class} keyword, followed by:
\begin{itemize}
    \item the class name (by convention, written in \texttt{CamelCase})
    \item a colon \mintinline{python}{:}
    \item an indented block of code
\end{itemize}

\begin{minted}{python}
class Person:
    pass
\end{minted}

This defines an empty class. It does not do anything yet, but it gives Python a
new type called \mintinline{python}{Person}.

\subsection{Creating Objects}
\index{objects}
An \newterm{object}\index{objects!definition} is an instance of a class. Objects are created
by calling the class name like a function.

\begin{minted}{python}
p1 = Person()
p2 = Person()
\end{minted}

Here, \mintinline{python}{p1} and \mintinline{python}{p2} are two separate objects, both created
from the same class.

\subsection{The \texttt{\_\_init\_\_} Method}
\index{init}
Most classes need to store data. This is done using a special function called
\mintinline{python}{__init__}. This function runs automatically when a new object is created.

\begin{minted}{python}
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
\end{minted}

The parameter \mintinline{python}{self} refers to the current object being created.
Each object gets its own copy of the variables defined using \mintinline{python}{self}.

\begin{minted}{python}
p = Person("Alex", 20)
\end{minted}

Now the object \mintinline{python}{p} has two attributes:
\begin{itemize}
    \item \mintinline{python}{p.name}
    \item \mintinline{python}{p.age}
\end{itemize}

\subsection{Accessing Object Attributes}
\index{attributes}
Attributes are accessed using dot notation.

\begin{minted}{python}
print(p.name)
print(p.age)
\end{minted}

Output:
\begin{minted}{text}
Alex
20
\end{minted}

Each object stores its own values. Creating another object does not overwrite
existing ones.

\subsection{Methods}
\index{methods}
Functions defined inside a class are called \newterm{methods}\index{methods!definition}.
Methods describe behavior that belongs to the object.

\begin{minted}{python}
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print("Hello, my name is", self.name)
\end{minted}

Calling a method uses dot notation:

\begin{minted}{python}
p = Person("Alex", 20)
p.greet()
\end{minted}

Output:
\begin{minted}{text}
Hello, my name is Alex
\end{minted}

\subsection{Printing Objects}
\index{printing objects}
By default, printing an object produces an unreadable result:

\begin{minted}{python}
print(p)
\end{minted}

Output (example):
\begin{minted}{text}
<__main__.Person object at 0x7f9c1a3d>
\end{minted}

This actually is the object's memory address in the computer's memory, but it may be a bit tedious want to print that and manually search ever byte. Instead, to control how an object is printed, we can define the special method
\mintinline{python}{__str__}.

\begin{minted}{python}
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name} ({self.age} years old)"
\end{minted}

Now printing the object gives a meaningful result:

\begin{minted}{python}
p = Person("Alex", 20)
print(p)
\end{minted}

Output:
\begin{minted}{text}
Alex (20 years old)
\end{minted}

\subsection{Why Use Classes?}
Classes allow us to:
\begin{itemize}
    \item group related data and behavior together
    \item create many objects with the same structure
    \item write code that is easier to understand and maintain
\end{itemize}

\subsection{Summary}
\begin{itemize}
    \item A class is a blueprint for creating objects
    \item Objects store data using attributes
    \item \mintinline{python}{__init__} initializes new objects
    \item Methods define behavior for objects
    \item \mintinline{python}{__str__} controls how objects are printed
    \item This was only a foundation of OOP; more advance concepts exist and are stronger in other programming languages such as Java and C++
\end{itemize}

\begin{Exercise}[label=classes1, title=Tracing an Object]
Consider the following code:
\begin{minted}{python}
class Counter:
    def __init__(self, value):
        self.value = value

    def increment(self):
        self.value += 1

c = Counter(5)
c.increment()
c.increment()
print(c.value)
\end{minted}

What is printed?
\end{Exercise}

\begin{Answer}[ref=classes1]
The initial value is 5. The \mintinline{python}{increment()} method is called twice,
so the value becomes 7. The program prints:
\begin{minted}{text}
7
\end{minted}
\end{Answer}

\begin{Exercise}[label=classes2, title=Custom Printing]
Write a class called \mintinline{python}{Book} that stores a title and an author.
Add a \mintinline{python}{__str__} method so that printing a book displays:
\begin{minted}{text}
Title by Author
\end{minted}
\end{Exercise}

\begin{Answer}[ref=classes2]
\begin{minted}{python}
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def __str__(self):
        return f"{self.title} by {self.author}"
\end{minted}
\end{Answer}

\section{Libraries}
\index{libraries}
A \emph{library} is a collection of pre-written code that provides additional
functionality without requiring you to write everything from scratch. Python
includes many built-in libraries that can be used to perform common tasks such as
mathematical calculations, data handling, and visualization. You'll often find that code you are seeking can be found through an open-source library which already exists.

To use a library, it must first be imported.

\subsection{Importing Libraries}

The simplest way to import a library is using the \mintinline{python}{import} keyword.

\begin{minted}{python}
import math
print(math.sqrt(16))
\end{minted}

In this example, the \mintinline{python}{math} library provides access to mathematical
functions such as square roots.

It is also possible to import specific values or functions from a library.

\begin{minted}{python}
from math import pi
print(pi)
\end{minted}

This allows direct access to \mintinline{python}{pi} without referencing the library name.

\subsection{Summary}

\begin{itemize}
    \item Libraries extend Python's functionality
    \item The \mintinline{python}{import} keyword is used to load libraries
    \item Specific components can be imported directly when needed
\end{itemize}

\section{Matplotlib}
Matplotlib is the most widely used plotting library in Python. It can produce simple charts quickly (line plots, scatter plots, bar charts, histograms) and also supports publication-quality figures with precise control over labels, legends, and layout. We will use it widely throughout this course to visualize data, create simulations for proving formulas, and experiment with datasets. 
\index{matplotlib}\index{creating charts in python|see{matplotlib}}
\subsection{Installing and importing}
If you are working locally, you can install Matplotlib with:
\begin{minted}{bash}
pip install matplotlib
\end{minted}

In most scripts, you will import the plotting interface \texttt{pyplot}:
\begin{minted}{python}
import matplotlib.pyplot as plt
\end{minted}

\subsection{A simple line graph}
A line plot is ideal for showing how a value changes over time or across an ordered variable. Let's create \texttt{line.py} 

\begin{minted}{python}
import matplotlib.pyplot as plt # the matplotlib library, which we will call using plt

# two lists containing values
x = [0, 1, 2, 3, 4, 5]
y = [0, 1, 4, 9, 16, 25]

# a 2d plot, used for line graphs
plt.plot(x, y)
# add a title to our plot
plt.title("A Simple Line Plot")
# add axis labels
plt.xlabel("x")
plt.ylabel("y = x^2")
plt.show() # pops up a new window
\end{minted}
Running \mintinline{bash}|python3 line.py| will open a new \emph{interactive window} in your computer, with the following image:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{line.png}
    \caption{The output of line.py.}
    \label{fig:line}
\end{figure}

\subsection{Labels, legends, and grids}
A plot is more useful when it clearly communicates what each element represents. Let's add on to \texttt{line.py} by creating \texttt{lineTwoOutputs.py} and adding labels, a legend, and another set of data. 


\begin{minipage}[t]{0.44\textwidth}
\begin{minted}{python}
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]
y1 = [0, 1, 4, 9, 16, 25]
y2 = [0, 1, 8, 27, 64, 125]

plt.plot(x, y1, label="x^2")
plt.plot(x, y2, label="x^3")

plt.title("Two Functions on One Axes")
plt.xlabel("x")
plt.ylabel("value")
plt.grid(True)
plt.legend()
plt.show()
\end{minted}
\end{minipage}
\begin{minipage}[t]{0.54\textwidth}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{lineTwoOutputs.png}
    \caption{$y=x^2$ and $y=x^3$ on the same graphed.}
    \label{fig:lineTwoOutputs}
\end{figure}
\end{minipage}
\subsection{Visualizing Relationships with scatter plots}
Scatter plots are excellent for showing how two variables relate (for example, height and weight). 

This very basic scatter plot shows the relationship between studying time and score.

\begin{minipage}[t]{0.44\textwidth}
    
    \begin{minted}{python}
    import matplotlib.pyplot as plt

    hours = [1, 2, 3, 4, 5, 6]
    scores = [55, 60, 66, 72, 78, 85]

    plt.scatter(hours, scores)
    plt.title("Study Time vs. Score")
    plt.xlabel("hours studied")
    plt.ylabel("score")
    plt.show()
    \end{minted}
\end{minipage}
\begin{minipage}[t]{0.54\textwidth}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{scatter.png}
    \caption{A scatterplot generated by matplotlib from the given data.}
    \label{fig:scatter}
\end{figure}
\end{minipage}


\subsection{Histograms and Distributions}
A histogram shows how values are distributed and how common different ranges are.

\begin{minipage}[t]{0.44\textwidth}

\begin{minted}{python}
import matplotlib.pyplot as plt
# a set of data, for example maybe these are all test scores
data = [4, 5, 5, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 11, 12]

# creates a histogram plot
plt.hist(data, bins=5)
plt.title("Histogram of Values")
plt.xlabel("value")
plt.ylabel("frequency")
plt.show()
\end{minted}
\end{minipage}
\hfill
\begin{minipage}[t]{0.54\textwidth}
    
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{histogram.png}
    \caption{A histogram of a set of data.}
    \label{fig:histogram}
\end{figure}
        
\end{minipage}

\subsection{The object-oriented approach (recommended)}
Matplotlib has two main styles:
\begin{itemize}
  \item \textbf{State-based} (using \texttt{plt.plot}, \texttt{plt.title}, \dots): quick and convenient.
  \item \textbf{Object-oriented} (creating a \texttt{Figure} and \texttt{Axes}): more explicit and easier to scale.
\end{itemize}

For multi-plot layouts or different analysis of datasets, prefer the object-oriented approach:
    
\begin{minted}{python}
import matplotlib.pyplot as plt

x = [0, 1, 2, 3, 4, 5]
y1 = [0, 1, 4, 9, 16, 25]
y2 = [0, 1, 8, 27, 64, 125]

# two figures, side by side. axes becomes an indexable list
fig, axes = plt.subplots(nrows=1, ncols=2)

axes[0].plot(x, y1)
axes[0].set_title("x^2")
axes[0].set_xlabel("x")
axes[0].set_ylabel("value")

axes[1].plot(x, y2)
axes[1].set_title("x^3")
axes[1].set_xlabel("x")
axes[1].set_ylabel("value")

fig.suptitle("Two Subplots")
fig.tight_layout()
plt.show()
\end{minted}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{lineOOP.png}
    \caption{The two plots, generated side by side.}
    \label{fig:lineOOP}
\end{figure}

\section{Errors}
Even the most experienced programmers can make mistakes. If the code seems to run into issues, your code may crash or output an \newterm{error}\index{Errors}. Python reports errors by raising a halt in the console output, which include a message explaining the problem and the exact line where it occurred. By learning how to read and interpret these messages, you'll be able to \newterm{debug}, or fix issues, in your programs more efficiently and write more reliable code.

You will encounter two main types of errors in your code: \textbf{Syntax Errors} and \textbf{Runtime Errors/Exceptions}. 
\begin{itemize}
    \item Syntax errors occur when your the formatting, or \newterm{syntax}. These errors can usually be found before your code is compiled.
    \item Runtime Errors, or \emph{Exceptions}, occur when operations in your code cause an invalid calculation, or attempt to do an invalid action. These can range anywhere from basic misnamed variables to imported libraries crashing from incorrect data.
\end{itemize}



\subsection{Syntax Errors}
\index{syntax errors}
What do you notice is immediately wrong with this code?
\begin{minted}{python}
    x = "Welcome Home"
    print(type(x)
\end{minted}

If we run it, we get the output:
\begin{minted}{python}
Traceback (most recent call last):
  File "<string>", line 1, in <module>
  File "/usr/lib/python3.12/py_compile.py", line 150, in compile
    raise py_exc
py_compile.PyCompileError:   File "./prog.py", line 2
    print(type(x)
         ^
SyntaxError: '(' was never closed
\end{minted}

We notice that every opening parentheses, bracket, or brace must have a closing supplement. Without out, we run into Syntax Errors, letting us know our format is off. 

Another type of Syntax Error can be found in incorrect indentation. Take for example the following code:
\begin{minted}{python}
if True:
print("Hello!")
\end{minted}
Output:
\begin{minted}{python}
Traceback (most recent call last):
  File "<string>", line 1, in <module>
  File "/usr/lib/python3.12/py_compile.py", line 150, in compile
    raise py_exc
py_compile.PyCompileError: Sorry: IndentationError: expected an indented block after 'if' statement on line 1 (prog.py, line 2)
\end{minted}

Here, there is no indentation (usually obtained by pressing the \verb|Tab| key on your keyboard) for lines under the conditional statement. This causes a Syntax Error to be raised.
\subsection{Exceptions}
Let's say I try to run the following code:

\begin{minted}{python}
    print(x)
    x = "hello"
\end{minted}

You may see the following output:
\begin{minted}{python}
Traceback (most recent call last):
    File "./program.py", line 1, in <module>
NameError: name 'x' is not defined
\end{minted}

You have encounted a \emph{NameError}, because \mintinline{python}{x} was not assigned before it was attempted to be printed. This brings up an important note on Python code: \textbf{code is executed line-by-line, sequentially}. So even if you define \mintinline{python}{x} after you try and print it, Python will not understand what you are trying to print. Let's look at another example:

\subsection{Try-Except}
\index{try-except}
\begin{minted}{python}
try:
    x = int(input("Enter a number: "))
    print(10 / x)
except ValueError:
    print("Please enter a valid integer.")
except ZeroDivisionError:
    print("Cannot divide by zero.")
\end{minted}
Here, we attempt to divide 10 by some input number $x$. There are two \mintinline{python}{Exceptions} that could cause this to fail:
\begin{itemize}
    \item The user inputs a string a characters, or anything that isn't an integer
    \item The user inputs 0, an invalid divisor.
\end{itemize}
We use a \mintinline{python}{Try-Except} block to check for different errors generated, similar to an if statement. The try block surrounds a block of code that may cause faulty runtime output or errors. 

\begin{Exercise}[label=exceptions1, title=Fix the Code]
\begin{minted}{python}
items = ["pen", "book", "eraser", "ruler"]

index = input("Enter an index (0 to 3): ")
print("You chose:", items[index])

items.remove("pencil")
print("Updated list:", items)
\end{minted}
Name two errors that could occur when this code is run. For each error, explain why it occurs and how to fix it.
\end{Exercise}
\begin{Answer}[ref=exceptions1]
\begin{enumerate}
    \item \textbf{TypeError}: The \mintinline{python}{input()} function returns a string, so when the user inputs an index, it is treated as a string. Attempting to use this string as an index for the list will raise a \mintinline{python}{TypeError}. To fix this, we can cast the input to an integer using \mintinline{python}{int()} and handle the potential \mintinline{python}{ValueError} if the input is not a valid integer.
    \item Pencil is not in the list, so attempting to remove it will raise a \mintinline{python}{ValueError}. To fix this, we can use a try-except block to catch the \mintinline{python}{ValueError} and print a message indicating that the item was not found in the list.
\end{enumerate}
\end{Answer}