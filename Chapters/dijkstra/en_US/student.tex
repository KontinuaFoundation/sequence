\chapter{Dijkstra's Algorithm}

Add a method to the \pytype{Graph} class that implements Dijkstra's algorithm:
\begin{verbatim}
    def cost_from_node(self, origin_node):
        # Cost of cheapest path from origin node discovered so far
        dist = {k: math.inf for k in self.nodes}

        # The previous city on that cheapest path
        prev = {}

        # All the nodes start as unvisited
        unvisited = set(self.nodes)
    
        # The distance from the origin node to itself is zero
        dist[origin_node] = 0.0

        # While there are still unvisited nodes
        while unvisited:

            # Find unvisited node with lowest cost
            min_cost = math.inf
            for u in unvisited:
                if dist[u] < min_cost:
                    current_node = u
                    min_cost = dist[u]

            # If none are less than inf, we are done
            # This happens in graphs that are not connected
            if min_cost == math.inf:
                return (dist, prev)
            
            # Remove the lowest cost node from the unvisited list
            unvisited.remove(current_node)

            # Update all the unvisited neighbors
            for edge in current_node.edges:

                # What node is at the other end of this edge?
                v = edge.other_end(current_node)

                # Visited nodes are already minimized, skip them
                if v not in unvisited:
                    continue

                # Is this a shorter route?
                alt = dist[current_node] + edge.cost
                if alt < dist[v]:

                    # Update the distance and prev dicts
                    dist[v] = alt
                    prev[v] = current_node

        return (dist, prev)
\end{verbatim}

Append some code to your \filename{cities.py} that test this method:

\begin{verbatim}
(cost_from_long_beach, prev) = network.cost_from_node(long_beach)
print(f"\nMinimum costs from Long Beach = {cost_from_long_beach}")
print(f"\nLast city before = {prev}")

nyc_cost = cost_from_long_beach[nyc]

if nyc_cost < math.inf:
    print(f"\n*** Total cost from Long Beach to NYC: ${nyc_cost:.2f} ***")
else:
    print("You can't get to NYC from Long Beach")
\end{verbatim}

When you run it, you should get a list of how much it costs to ship a
container to each city from Long Beach:
\begin{verbatim}
Minimum costs from Long Beach = {(node:Long Beach, edges:1): 0.0,
(node:Los Angeles, edges:3): 12.0, (node:Denver, edges:3): 35.0,
(node:Pheonix, edges:3): 31.0, (node:Louisville, edges:3): 49.0,
(node:Cleveland, edges:4): 44.0, (node:Boston, edges:2): 57.0,
(node:New York City, edges:3): 52.0}
\end{verbatim}

You will also get a collection of node pairs. What are these? For each
node, you get the node that you would pass through on the cheapest
route from Long Beach:
\begin{verbatim}
Last city before = {(node:Los Angeles, edges:3):(node:Long Beach, edges:1),
(node:Denver, edges:3):(node:Los Angeles, edges:3),
(node:Pheonix, edges:3):(node:Los Angeles, edges:3),
(node:Louisville, edges:3):(node:Denver, edges:3),
(node:Cleveland, edges:4):(node:Denver, edges:3),
(node:New York City, edges:3):(node:Cleveland, edges:4),
(node:Boston, edges:2): (node:Cleveland, edges:4)}
\end{verbatim}

Your users won't want to read this; Give them the shortest path as a list.  Add a function to
\filename{graph.py} that turns the \pyvar{prev} table into a path of
nodes that lead from the origin to the destination:

\begin{verbatim}
def shortest_path(prev, destination):

    # Include the destination in the path
    path = [destination]
    current_node = destination

    # Keep stepping backward in the path
    while current_node in prev:

        # What node should come before the current node?
        previous_node = prev[current_node]

        # Insert it at the start of the list
        path.insert(0, previous_node)
        current_node = previous_node

    return path
\end{verbatim}

Test that out:

\begin{Verbatim}[commandchars=\\\{\}]
if nyc_cost < math.inf:
    print(f"*** Total cost from Long Beach to NYC: ${nyc_cost:.2f} ***")

    \textbf{path_to_nyc = graph.shortest_path(prev, nyc)}
    \textbf{print(f"*** Cheapest path from Long Beach to NYC: {path_to_nyc} ***")}
else:
    print("You can't get to NYC from Long Beach")
\end{Verbatim}

This should look like this:
\begin{verbatim}
*** Cheapest path from Long Beach to NYC: [(node:Long Beach, edges:1),
(node:Los Angeles, edges:3), (node:Denver, edges:3), (node:Cleveland, edges:4),
(node:New York City, edges:3)] ***
\end{verbatim}
